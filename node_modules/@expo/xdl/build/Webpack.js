"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.startAsync = startAsync;
exports.stopAsync = stopAsync;
exports.openAsync = openAsync;
exports.bundleAsync = bundleAsync;
exports.getProjectNameAsync = getProjectNameAsync;
exports.getServer = getServer;
exports.getPort = getPort;
exports.getUrlAsync = getUrlAsync;
exports.getProtocolAsync = getProtocolAsync;
exports.getAvailablePortAsync = getAvailablePortAsync;
exports.setMode = setMode;
exports.DEFAULT_PORT = exports.HOST = void 0;

function ConfigUtils() {
  const data = _interopRequireWildcard(require("@expo/config"));

  ConfigUtils = function () {
    return data;
  };

  return data;
}

function _chalk() {
  const data = _interopRequireDefault(require("chalk"));

  _chalk = function () {
    return data;
  };

  return data;
}

function _formatWebpackMessages() {
  const data = _interopRequireDefault(require("react-dev-utils/formatWebpackMessages"));

  _formatWebpackMessages = function () {
    return data;
  };

  return data;
}

function _WebpackDevServerUtils() {
  const data = require("react-dev-utils/WebpackDevServerUtils");

  _WebpackDevServerUtils = function () {
    return data;
  };

  return data;
}

function _webpack() {
  const data = _interopRequireDefault(require("webpack"));

  _webpack = function () {
    return data;
  };

  return data;
}

function _webpackDevServer() {
  const data = _interopRequireDefault(require("webpack-dev-server"));

  _webpackDevServer = function () {
    return data;
  };

  return data;
}

function _getenv() {
  const data = _interopRequireDefault(require("getenv"));

  _getenv = function () {
    return data;
  };

  return data;
}

function _createWebpackCompiler() {
  const data = _interopRequireDefault(require("./createWebpackCompiler"));

  _createWebpackCompiler = function () {
    return data;
  };

  return data;
}

function _ip() {
  const data = _interopRequireDefault(require("./ip"));

  _ip = function () {
    return data;
  };

  return data;
}

function Doctor() {
  const data = _interopRequireWildcard(require("./project/Doctor"));

  Doctor = function () {
    return data;
  };

  return data;
}

function ProjectUtils() {
  const data = _interopRequireWildcard(require("./project/ProjectUtils"));

  ProjectUtils = function () {
    return data;
  };

  return data;
}

function ProjectSettings() {
  const data = _interopRequireWildcard(require("./ProjectSettings"));

  ProjectSettings = function () {
    return data;
  };

  return data;
}

function Web() {
  const data = _interopRequireWildcard(require("./Web"));

  Web = function () {
    return data;
  };

  return data;
}

function _XDLError() {
  const data = _interopRequireDefault(require("./XDLError"));

  _XDLError = function () {
    return data;
  };

  return data;
}

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = Object.defineProperty && Object.getOwnPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : {}; if (desc.get || desc.set) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } } newObj.default = obj; return newObj; } }

//eslint-disable-line
const HOST = _getenv().default.string('WEB_HOST', '0.0.0.0');

exports.HOST = HOST;

const DEFAULT_PORT = _getenv().default.int('WEB_PORT', 19006);

exports.DEFAULT_PORT = DEFAULT_PORT;
const WEBPACK_LOG_TAG = 'expo';
let webpackDevServerInstance = null;
let webpackServerPort = null;

async function startAsync(projectRoot, options = {}, deprecatedVerbose) {
  if (typeof deprecatedVerbose !== 'undefined') {
    throw new (_XDLError().default)('WEBPACK_DEPRECATED', 'startAsync(root, options, verbose): The `verbose` option is deprecated.');
  }

  if (webpackDevServerInstance) {
    ProjectUtils().logError(projectRoot, WEBPACK_LOG_TAG, 'Webpack is already running.');
    return;
  }

  const {
    env,
    config
  } = await createWebpackConfigAsync(projectRoot, options);
  webpackServerPort = await getAvailablePortAsync({
    defaultPort: options.port
  });
  ProjectUtils().logInfo(projectRoot, WEBPACK_LOG_TAG, `Starting Webpack on port ${webpackServerPort} in ${_chalk().default.underline(env.mode)} mode.`);
  const protocol = env.https ? 'https' : 'http';
  const urls = (0, _WebpackDevServerUtils().prepareUrls)(protocol, '::', webpackServerPort);
  const useYarn = ConfigUtils().isUsingYarn(projectRoot);
  const appName = await getProjectNameAsync(projectRoot);
  const nonInteractive = validateBoolOption('nonInteractive', options.nonInteractive, process.stdout.isTTY);
  await new Promise(resolve => {
    // Create a webpack compiler that is configured with custom messages.
    const compiler = (0, _createWebpackCompiler().default)({
      projectRoot,
      nonInteractive,
      webpack: _webpack().default,
      appName,
      config,
      urls,
      useYarn,
      onFinished: resolve
    });
    webpackDevServerInstance = new (_webpackDevServer().default)(compiler, config.devServer); // Launch WebpackDevServer.

    webpackDevServerInstance.listen(webpackServerPort, HOST, error => {
      if (error) {
        ProjectUtils().logError(projectRoot, WEBPACK_LOG_TAG, error);
      }

      if (typeof options.onWebpackFinished === 'function') {
        options.onWebpackFinished(error);
      }
    });
  });
  await ProjectSettings().setPackagerInfoAsync(projectRoot, {
    webpackServerPort
  });

  const host = _ip().default.address();

  return {
    url: `${protocol}://${host}:${webpackServerPort}`,
    server: webpackDevServerInstance,
    port: webpackServerPort,
    protocol,
    host
  };
}

async function stopAsync(projectRoot) {
  if (webpackDevServerInstance) {
    await new Promise(resolve => webpackDevServerInstance.close(() => resolve()));
    webpackDevServerInstance = null;
    webpackServerPort = null;
    await ProjectSettings().setPackagerInfoAsync(projectRoot, {
      webpackServerPort: null
    });
  }
}

async function openAsync(projectRoot, options) {
  if (!webpackDevServerInstance) {
    await startAsync(projectRoot, options);
  }

  await Web().openProjectAsync(projectRoot);
}

async function bundleAsync(projectRoot, options) {
  const {
    config
  } = await createWebpackConfigAsync(projectRoot, options);
  const compiler = (0, _webpack().default)(config);

  try {
    // We generate the stats.json file in the webpack-config
    const {
      warnings
    } = await new Promise((resolve, reject) => compiler.run((error, stats) => {
      let messages;

      if (error) {
        if (!error.message) {
          return reject(error);
        }

        messages = (0, _formatWebpackMessages().default)({
          errors: [error.message],
          warnings: []
        });
      } else {
        messages = (0, _formatWebpackMessages().default)(stats.toJson({
          all: false,
          warnings: true,
          errors: true
        }));
      }

      if (messages.errors.length) {
        // Only keep the first error. Others are often indicative
        // of the same problem, but confuse the reader with noise.
        if (messages.errors.length > 1) {
          messages.errors.length = 1;
        }

        return reject(new Error(messages.errors.join('\n\n')));
      }

      if (process.env.CI && (typeof process.env.CI !== 'string' || process.env.CI.toLowerCase() !== 'false') && messages.warnings.length) {
        console.log(_chalk().default.yellow('\nTreating warnings as errors because process.env.CI = true.\n' + 'Most CI servers set it automatically.\n'));
        return reject(new Error(messages.warnings.join('\n\n')));
      }

      resolve({
        stats,
        warnings: messages.warnings
      });
    }));

    if (warnings.length) {
      console.log(_chalk().default.yellow('Compiled with warnings.\n'));
      console.log(warnings.join('\n\n'));
    } else {
      console.log(_chalk().default.green('Compiled successfully.\n'));
    }
  } catch (error) {
    console.log(_chalk().default.red('Failed to compile.\n'));
    throw error;
  }
}

async function getProjectNameAsync(projectRoot) {
  const {
    exp
  } = await ProjectUtils().readConfigJsonAsync(projectRoot);
  const {
    webName
  } = ConfigUtils().getNameFromConfig(exp);
  return webName;
}

function getServer(projectRoot) {
  if (webpackDevServerInstance == null) {
    ProjectUtils().logError(projectRoot, WEBPACK_LOG_TAG, 'Webpack is not running.');
  }

  return webpackDevServerInstance;
}

function getPort() {
  return webpackServerPort;
}

async function getUrlAsync(projectRoot) {
  const devServer = getServer(projectRoot);

  if (!devServer) {
    return null;
  }

  const host = _ip().default.address();

  const protocol = await getProtocolAsync(projectRoot);
  return `${protocol}://${host}:${webpackServerPort}`;
}

async function getProtocolAsync(projectRoot) {
  // TODO: Bacon: Handle when not in expo
  const {
    https
  } = await ProjectSettings().readAsync(projectRoot);
  return https === true ? 'https' : 'http';
}

async function getAvailablePortAsync(options = {}) {
  try {
    return await (0, _WebpackDevServerUtils().choosePort)(options.host || HOST, options.defaultPort || DEFAULT_PORT);
  } catch (error) {
    throw new (_XDLError().default)('NO_PORT_FOUND', 'No available port found: ' + error.message);
  }
}

function setMode(mode) {
  process.env.BABEL_ENV = mode;
  process.env.NODE_ENV = mode;
}

function validateBoolOption(name, value, defaultValue) {
  if (typeof value === 'undefined') {
    value = defaultValue;
  }

  if (typeof value !== 'boolean') {
    throw new (_XDLError().default)('WEBPACK_INVALID_OPTION', `'${name}' option must be a boolean.`);
  }

  return value;
}

function transformCLIOptions(options) {
  // Transform the CLI flags into more explicit values
  return { ...options,
    isImageEditingEnabled: options.pwa,
    isPolyfillEnabled: options.polyfill
  };
}

async function createWebpackConfigAsync(projectRoot, options = {}) {
  const fullOptions = transformCLIOptions(options);

  if (validateBoolOption('isValidationEnabled', fullOptions.isValidationEnabled, true)) {
    await Doctor().validateWebSupportAsync(projectRoot);
  }

  const env = await getWebpackConfigEnvFromBundlingOptionsAsync(projectRoot, fullOptions);
  setMode(env.mode);
  const config = await Web().invokeWebpackConfigAsync(env);
  return {
    env,
    config
  };
}

async function applyOptionsToProjectSettingsAsync(projectRoot, options)
/*: ProjectSettings */
{
  let newSettings = {}; // Change settings before reading them

  if (typeof options.https === 'boolean') {
    newSettings.https = options.https;
  }

  if (typeof options.dev === 'boolean') {
    newSettings.dev = options.dev;
  }

  if (Object.keys(newSettings).length) {
    await ProjectSettings().setAsync(projectRoot, newSettings);
  }

  return await ProjectSettings().readAsync(projectRoot);
}

async function getWebpackConfigEnvFromBundlingOptionsAsync(projectRoot, options) {
  let {
    dev,
    https
  } = await applyOptionsToProjectSettingsAsync(projectRoot, options);
  const mode = typeof options.mode === 'string' ? options.mode : dev ? 'development' : 'production';
  const isImageEditingEnabled = validateBoolOption('isImageEditingEnabled', options.isImageEditingEnabled, true);
  const isDebugInfoEnabled = validateBoolOption('isDebugInfoEnabled', options.isDebugInfoEnabled, Web().isInfoEnabled());
  return {
    projectRoot,
    pwa: isImageEditingEnabled,
    mode,
    https,
    polyfill: validateBoolOption('isPolyfillEnabled', options.isPolyfillEnabled, false),
    development: dev,
    production: !dev,
    info: isDebugInfoEnabled,
    ...(options.webpackEnv || {})
  };
}
//# sourceMappingURL=__sourcemaps__/Webpack.js.map
